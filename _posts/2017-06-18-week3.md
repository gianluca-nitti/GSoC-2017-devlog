---
date: 2017-06-18
category: week3
---

#### Implemented resource management
Since the latest update I mainly worked on the code to provide access to certain resources to WebSocket and HTTP clients; the code is on the [resources](https://github.com/gianluca-nitti/FacadeServer/tree/resources) branch. Here is a class diagram showing the architecture of the interfaces and classes which represent resources, together with the Console resource (the only one available at the moment):

![ClassDiagram]({{ site.baseurl }}/images/ResourceClassDiagram.PNG)

Some notes:

{:.details}
- The Resource interface simply states that a class implementing it is a resource and must provide a name.
- Then there are three main families of resources: WritableResource, ReadableResource and EventEmittingResource. As you can easily guess by the names, they define the methods that a resource must implement if it accepts data to be written to it, if it can provide data "on-demand" and if it emits events. The latest one is a class instead of an interface, because it implements internally the logic to register observers and notifying them.
- All the three kinds of resources are typed, i.e. a ReadableResource has a type parameter which determines the class of the objects which are obtained when reading this resource. WritableResource also has a method to get the Class object representing the type, which is necessary to deserialize client messages.
- The clients are identified by the same EntityRef objects which identify them in the engine.
- While EventEmittingResource and ObservableReadableResource look very similar, there are key differences between them. An EventEmittingResource produces data only by raising events, and can't be queried directly; the ObservableReadableResource class is an addition to a ReadableResource (which can be read "on-demand") that allows the subclasses to notify clients when the data has changed. At the data transport level, the server sends to WebSocket clients both the events generated by EventEmittingResources and the updates from ObservableReadableResources; for HTTP clients, the server can't directly send data to clients, so events are saved in a queue that the client can query by periodically sending a GET request to a certain endpoint, while there is no "update queue" for ObservableReadableResources (it wouldn't make sense to store, for example, all the changes to the number of connected users, which could be an ObservableReadableResource&lt;Integer&gt;); the client can simply send GET requests to periodically read the resource of interest to always obtain the latest value.
- (Not shown in the diagram) There is then a ResourceManager class which works as a registry of the instances of the resources and provides methods to access them according to their capabilities. The ResourceManager is used by the JsonSession class - which in turn is used by the classes which implement the WebSocket and HTTP protocols - to query or perform actions on the resources when requested by clients, or when a resource sends a notification.
- At the moment I implemented a ConsoleResource; clients can write strings (commands to be executed) to it and receive MessageEvents for each message that the server writes to the console.
- The [simple WebSocket client](https://gist.github.com/gianluca-nitti/14e5d61d66d1f347330fa7f42f3db7da) has also been updated to keep compatibility with the backend changes; now, it also allows to send messages to query resources and it shows the received messages/events. Here is a screenshot showing the execution of a console command (the *help* command). There are still some character encoding issues - I guess the problem is in the serialization of MessageEvents - which will be fixed later.

![Screenshot]({{ site.baseurl }}/images/client-test-console.PNG)

The next goals are allowing anonymous (without authentication) access to certain ReadableResources which will be developed, for example server information resources (connected players, MOTD, ...), and starting to work on the "real" web frontend.
