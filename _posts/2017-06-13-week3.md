---
date: 2017-06-13
category: week3
---

#### A couple of words about HTTP and WebSocket
Until now, I talked about WebSocket, HTTP and used the generic term "web API" without going into much detail; probably, it's time (maybe a bit late) to clearly explain on this site what king of interface will be available to externally access a Terasology server running inside FacadeServer.

{:.details}
- The idea, as I mentioned in the GSoC proposal, is that the scenario where an user is connected to a Terasology server through a web application (which will be developed during the next weeks/months) is potentially an higly interactive environment suited for "push"-style notifications from the server to the client. For example when a new chat message (perhaps sent by another user connected through a regular Terasology client) is received by the server, the server must "send" (quotes since it can look unfamiliar if you are used to the "traditional" style of a web server only answering requests sent by clients) it to the client connected through the web interface.
- Until some years ago, this would have been possible only by having the client to periodically [poll](https://en.wikipedia.org/wiki/Polling_(computer_science)) the server for updates. Nowadays, however, all the major browsers support [WebSocket](https://en.wikipedia.org/wiki/WebSocket), a protocol much more suited for real-time bidirectional communication than regular HTTP.
- Providing only a WebSocket-based interface to the server, however, would be probably a little restrictive. One of the goals of the project is to provide an Application Programming Interface to allow arbitrary software to interact with a Terasology server (the other one is to provide a browser-based user friendly interface to it as described above); as a very simple example, one may want to retrieve the number of connected players from a shell script. Doing something like this via WebSocket would be cumbersome, if possible at all; you'd have to use a command line WebSocket client like [wscat](https://en.wikipedia.org/wiki/WebSocket) and in some way configure it to send a certain message to ask the server the required piece of information and wait for the server to answer. A much better way to accomplish a goal like this would be to have HTTP endpoints exposed by the server and querying them with curl.
- So, in the optimal setup, the server should expose *both* a WebSocket *and* a standard HTTP interface. In my understanding, this can be accomplished quite well by abstracting, in the server architecture, the accessible resources from the communication protocol. The [JsonSession](https://github.com/gianluca-nitti/FacadeServer/blob/authentication/src/main/java/org/terasology/web/io/JsonSession.java) class handles the object serialization/deserialization with the JSON data format, but is not aware of the transfer protocol; other classes, [WsHandler](https://github.com/gianluca-nitti/FacadeServer/blob/authentication/src/main/java/org/terasology/web/webSocket/WsHandler.java) for WebSocket and [HttpAPIServlet](https://github.com/gianluca-nitti/FacadeServer/blob/authentication/src/main/java/org/terasology/web/servlet/HttpAPIServlet.java) - added yesterday - for HTTP, work as a bridge between the transfer protocol and method calls to JsonSession instances. At the moment only the authentication handshake is handled, but this structure is designed to provide access to any resource, too, regardless of the used protocol. A request from the client to the server will result in a method of JsonSession being called and the returned object to be sent as the response, while an event generated by a resource would be notified by the JsonSession - using the [Observer Pattern](https://en.wikipedia.org/wiki/Observer_pattern) - to the appropriate handler and sent to the client by directly sending a message (if WebSocket) or by enqueuing it in a buffer that the user can read by requesting a certain endpoint (if HTTP).
- A diagram can probably express the concept better. Maybe this is not the best example since sending a chat message is an action that doesn't need to be answered with data, but I think it still shows the main idea for handling requests from both the protocols:
![Diagram]({{ site.baseurl }}/images/diagram.svg)

Now that I (hopefully) explained this part about protocols, here is a short summary of yesterday's and today's work (since the previous update):

{:.details}
- I implemented the HTTP interface to the authentication system. When the client initiates the handshake, a session token is generated and sent to the client; all the further requests must use that token in an HTTP header so that the server can verify the client's identity. Code is in the [HttpAPIServlet](https://github.com/gianluca-nitti/FacadeServer/blob/authentication/src/main/java/org/terasology/web/servlet/HttpAPIServlet.java) class.
- Then, I made a small proof-of-concept Javascript client which authenticates with a server using WebSocket. This is mainly to show that it's possible to do the cryptography part (signing the verification data) in a browser, with the help of a library like [jsrsasign](https://github.com/kjur/jsrsasign). A problem I encountered is that it's not simple to deserialize a "normal" configuration file as it's saved by a Terasology client because of the big integers used in certificates. Looks like it's not possible with the vanilla *JSON.parse()* but it's necessary to use external libraries like [json-bigint](https://www.npmjs.com/package/json-bigint), but this should not be much of a problem since the real front-end client will most likely use [browserify](http://browserify.org/) to manage browser-side libraries and thus easily support NPM modules such as json-bigint. For now, this very simple client only accepts a configuartion where the BigIntegers are serialized as the base64 of their binary representation, as in the [client identity storage service](http://forum.terasology.org/threads/client-identity-cloud-storage-service.1846).
I posted the code (single file) as a [gist](https://gist.github.com/gianluca-nitti/14e5d61d66d1f347330fa7f42f3db7da), and here is a screenshot:
![Screenshot]({{ site.baseurl }}/images/client-test.PNG)
